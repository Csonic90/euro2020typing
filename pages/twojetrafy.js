import React, { useState } from 'react'
import {
  useAuthUser,
  withAuthUser,
  withAuthUserTokenSSR,
  AuthAction,
} from 'next-firebase-auth'
import Countdown, {calcTimeDelta} from 'react-countdown';
import axios from 'axios'
import Header from '../components/Header'
import DemoPageLinks from '../components/DemoPageLinks'
import getAbsoluteURL from '../utils/getAbsoluteURL'
import db from '../utils/db';
import Head from 'next/head'
import styles from '../styles/Home.module.css'
import { route } from 'next/dist/next-server/server/router';
import { useRouter } from 'next/router'


const Twojetrafy = ({ userData, wyniki, mecze }) => {
  const AuthUser = useAuthUser()
  const router = useRouter()

  const [content, setContent] = useState(wyniki.sort((a, b) => a.ordertable - b.ordertable))
 

  const onChange = (e) => {
    if (["wynik_1", "wynik_2"].includes(e.target.name)) {
      const temp = [...content]
      temp[e.target.dataset.id][e.target.name] = e.target.value
      setContent(temp)
    }
    if (["imie"].includes(e.target.name)) {
      setImie(e.target.value)
    }
  }
  const onSubmit = async (e) => {
    const id = e.target.id
    const id_data = e.target.dataset.id
    const { wynik_1, wynik_2 } = content[id_data];
    console.log(wynik_1, wynik_2);
    await axios.put(`/api/wynik/${id}`, {
      wynik_1: wynik_1,
      wynik_2: wynik_2,
      status: (wynik_1 != '' && wynik_2 != '')
    });
    const temp = [...content]
      temp[e.target.dataset.id][e.target.name] = true
      setContent(temp)
    router.push('/twojetrafy')
  }
  const todaysDate = new Date()
  return (<>
    <Head>
      <title>EURO 2020</title>
      <meta name="description" content="Generated by create next app" />
      <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossOrigin="anonymous"></link>
      <link rel="icon" href="/favicon.ico" />
    </Head>

    <div className="container">

      <Header email={AuthUser.email} signOut={AuthUser.signOut} />
      <div >
        <div className="m-3" >
          {userData.map((a, id) =>
            <h1 key={id}> {a.name} postaw swoje typy! </h1>
          )}
        </div>
        <div>
          {mecze.map((mecz, id) =>
            <div className="row m-2" key={id}>

              <label className="col" htmlFor="fname">{mecz.druzyna1}</label>
              <input
                id="fname"
                name='wynik_1'
                data-id={id}
                type="number"
                value={content[id] && content[id].wynik_1}
                className="wynik col form-control"
                onChange={onChange}
                disabled={content[id] && content[id].status == true || Date.parse(mecz.blokada) < todaysDate }
              />
              <input
                id="fname"
                name='wynik_2'
                data-id={id}
                data-aaaa={mecz.id}
                type="number"
                value={content[id] && content[id].wynik_2}
                className="wynik col form-control"
                onChange={onChange}
                disabled={content[id] && content[id].status == true || Date.parse(mecz.blokada) < todaysDate }
              />
              <label className="col" htmlFor="fname">{mecz.druzyna2}</label>
              <button
                data-id={id}
                name="status"
                id={content[id] && content[id].id}
                data-aaaa={content[id].mecz_id}
                className={(content[id] && content[id].status == true || Date.parse(mecz.blokada) < todaysDate) ? "btn btn-outline-danger col" : "btn btn-outline-success col"}
                onClick={onSubmit}
                disabled={content[id] && content[id].status == true || Date.parse(mecz.blokada) < todaysDate}>
                <Countdown
                  date={mecze[id] && mecze[id].blokada }
                  intervalDelay={1000}
                  precision={0}
                  renderer={props => <div>{props.days}d {props.hours}g {props.minutes}m {props.seconds}s</div>}
                />
                {(content[id] && content[id].status == true || Date.parse(mecz.blokada) < todaysDate)? 'Zablokowany' : 'Zatwierdz'}
              </button>

            </div>
          )}
        </div>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossOrigin="anonymous"></script>
      </div>
    </div>
  </>
  )
}

export const getServerSideProps = withAuthUserTokenSSR({
  whenUnauthed: AuthAction.REDIRECT_TO_LOGIN,
})(async ({ AuthUser, req }) => {
  // Optionally, get other props.
  const token = await AuthUser.getIdToken()
  const endpoint = getAbsoluteURL('/api/example', req)
  const users = await db.collection('users').where('id_auth', '==', AuthUser.id).get();

  const userwynik = await db.collection('wyniks').where('id_user', '==', AuthUser.id).get();
  const meczes = await db.collection('meczes').orderBy('created', 'asc').get();

  const response = await fetch(endpoint, {
    method: 'GET',
    headers: {
      Authorization: token || 'unauthenticated',
    },
  })
  const data = await response.json()
  if (!response.ok) {
    throw new Error(
      `Data fetching failed with status ${response.status}: ${JSON.stringify(
        data
      )}`
    )
  }

  const userData = users.docs.map(usr => ({
    id: usr.id,
    ...usr.data()
  }));

  const wynikiData = userwynik.docs.map(wynik => ({
    id: wynik.id,
    ...wynik.data()
  }));

  const meczeData = meczes.docs.map(mecz => ({
    id: mecz.id,
    ...mecz.data()
  }));

  return {
    props: {
      favoriteColor: data.favoriteColor,
      userData: userData,
      wyniki: wynikiData,
      mecze: meczeData
    },
  }
})

export default withAuthUser({
  whenUnauthedAfterInit: AuthAction.REDIRECT_TO_LOGIN,
})(Twojetrafy)
